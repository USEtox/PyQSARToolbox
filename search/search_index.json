{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyQSARToolbox","text":"<p>PyQSARToolbox is a lightweight Python client for interacting with a locally running QSAR Toolbox Web API instance.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Discover calculators, QSAR models, profilers, workflows, metabolism simulators.</li> <li>Search chemicals by CAS, name, SMILES, or internal IDs.</li> <li>Retrieve endpoint trees, metadata, and experimental data.</li> <li>Apply QSAR models and profiling operations programmatically.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyqsartoolbox\n</code></pre> <p>For development (tests + docs):</p> <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pyqsartoolbox import QSARToolbox\n\n# Replace with your local toolbox port\nqs = QSARToolbox(port=62008)\nprint(qs.toolbox_version())\n\nchem = qs.search_name(\"benzene\")[0]\nprint(chem[\"ChemId\"], chem[\"Names\"])\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Get started here!</p>"},{"location":"api/","title":"API Reference","text":"<p>A class to connect to the local web server of the QSAR Toolbox. It requires  the QSAR Toolbox to be installed and running in the local computer. The user need to find the address and the  port of the local server and provide it to the class. Note: The port number can also be found automatically by running the following code: <pre><code>import requests\nfrom requests.exceptions import RequestException\nimport psutil\nfrom tqdm import tqdm\n\ndef find_open_port(endpoint=\"/about/toolbox/version\"):\n    # Get a list of all open ports on localhost with status LISTEN\n    open_ports = [conn.laddr.port for conn in psutil.net_connections() if conn.status == \"LISTEN\" and conn.laddr.ip == \"127.0.0.1\"]\n\n    for port in tqdm(open_ports):\n        url = f\"http://127.0.0.1:{port}/api/v6{endpoint}\"\n        try:\n            response = requests.get(url, timeout=1)\n            if response.status_code == 200:\n                return port\n        except RequestException:\n            continue\n    return None\n\n# Example usage\nport = find_open_port()\nif port:\n    print(f\"Server found on port {port}\")\nelse:\n    print(\"Server not found within the specified port range\")\n</code></pre></p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.all_profile_chemicals","title":"<code>all_profile_chemicals(chem_id)</code>","text":"<p>All Profilers for the specified chemical.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.applicability_domain_qsar_chemical","title":"<code>applicability_domain_qsar_chemical(chem_id, qsar_model_guid)</code>","text":"<p>Get the applicability domain for a QSAR model and a chemical. returns a string that specifies whether the chemical is in the domain or not.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.apply_qsar_chemical","title":"<code>apply_qsar_chemical(chem_id, qsar_model_guid)</code>","text":"<p>apply the specified QSAR model to a chemical.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.call_metabolism_simulator","title":"<code>call_metabolism_simulator(simulator_guid, chem_id, timeout=None)</code>","text":"<p>Call a metabolism simulator for a chemical.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.call_metabolism_simulator_on_SMILES","title":"<code>call_metabolism_simulator_on_SMILES(simulator_guid, smiles, timeout=None)</code>","text":"<p>Call a metabolism simulator for a chemical.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.call_qsar_model","title":"<code>call_qsar_model(chem_id, model_name='EPI Suite', end_point='VP')</code>","text":"<p>Call a QSAR model for a chemical. Returns a Dictionary.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.canonize_smiles","title":"<code>canonize_smiles(smiles)</code>","text":"<p>Canonize a SMILES string. Returns a string.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.extract_experimental_data","title":"<code>extract_experimental_data(chem_id, end_point='VP')</code>","text":"<p>Extract end point data for a chemical. Returns a Dictionary.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_CASRN_from_SMILES","title":"<code>get_CASRN_from_SMILES(smiles)</code>","text":"<p>Get the CASRN from a SMILES string. Returns a string.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_all_endpoint_data","title":"<code>get_all_endpoint_data(chem_id, includeMetadata=False)</code>","text":"<p>Get all the endpoint data for a chemid. It can take a long time to return the data. Consider increasing the timeout.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_available_calculators","title":"<code>get_available_calculators(timeout=None)</code>","text":"<p>Get all the available calculators in the QSAR Toolbox [     {         \"Caption\": \"string\",         \"Guid\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",         \"Units\": \"string\",         \"Is3D\": true,         \"IsExperimental\": true,         \"Description\": \"string\"     } ]</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_databases","title":"<code>get_databases()</code>","text":"<p>returns a list of the available databases in the QSAR Toolbox</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_databases_for_endpoint","title":"<code>get_databases_for_endpoint(position, endpoint, timeout=None)</code>","text":"<p>Get the databases for an endpoint</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_endpoint_data","title":"<code>get_endpoint_data(chem_id, position, endpoint, includeMetadata=False, timeout=120)</code>","text":"<p>Get the endpoint data for a chemid. Retrieves data for the specified endpoint at  the given position for the selected chemical Example: qs = QSARToolbox(port=52675)</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_endpoint_units_from_tree","title":"<code>get_endpoint_units_from_tree(position, endpoint, timeout=None)</code>","text":"<p>Get the units for an endpoint from the endpoint tree</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_endpoints_from_tree","title":"<code>get_endpoints_from_tree(position, timeout=None)</code>","text":"<p>Get the available endpoints at the given position. Returns a dictionary of the available endpoint depending on your installation of the QSAR Toolbox. position is a string that represents the position in the endpoint tree. For example, \"Physical Chemical Properties#Vapour pressure\" Example qs = QSARToolbox(port=52675) qs.get_endpoint_from_tree(\"Physical Chemical Properties#Vapour pressure\")</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_endpoints_tree","title":"<code>get_endpoints_tree(timeout=None)</code>","text":"<p>Get the endpoint tree. Returns a dictionary of the available endpoint calculation methods depending on your installation of the QSAR Toolbox.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_metabolism_simulators","title":"<code>get_metabolism_simulators()</code>","text":"<p>Get all available metabolism simulators.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_metadata_hierarchy","title":"<code>get_metadata_hierarchy(timeout=None)</code>","text":"<p>Get the metadata hierarchy. Returns a dictionary of the available metadata hierarchy depending on your installation of the QSAR Toolbox.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_object_info","title":"<code>get_object_info(object_guid)</code>","text":"<p>Get the information of an object by its GUID Example: qs = QSARToolbox(port=52675) qs.get_object_info(\"6bfe3c72-dff2-4e37-b5a1-ffa9a1a111d1\") The output is a JSON object.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_object_info_html","title":"<code>get_object_info_html(object_guid)</code>","text":"<p>Get the information of an object by its GUID in HTML format Example: qs = QSARToolbox(port=52675) qs.get_object_info_html(\"6bfe3c72-dff2-4e37-b5a1-ffa9a1a111d1\") The output is in html format.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_profilers","title":"<code>get_profilers()</code>","text":"<p>Get all available profilers.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_profiling_categories","title":"<code>get_profiling_categories(profiler_guid)</code>","text":"<p>Get the categories for a profiler.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_qsar_models","title":"<code>get_qsar_models(position)</code>","text":"<p>Get the QSAR models for a position in the endpoint tree.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.get_workflows","title":"<code>get_workflows()</code>","text":"<p>Get the workflows. Returns a dictionary of the available workflows depending on your installation of the QSAR Toolbox.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.profile_chemical","title":"<code>profile_chemical(profiler_guid, chem_id, simulator_guid)</code>","text":"<p>Profile a chemical using a profiler.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.run_all_calculators","title":"<code>run_all_calculators(chem_id, timeout=120)</code>","text":"<p>Get all the calculations for a chemical; parameter chem_id comes from the results of one of the search_ functions.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.run_calculator","title":"<code>run_calculator(calculation_guid, chem_id, timeout=None)</code>","text":"<p>Get the result of a calculation for a chemical; parameter chem_id comes from the results of one of the search_ functions. the calculation_guid comes from the get_calculations() function.</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.search_CAS","title":"<code>search_CAS(casrn, ignoreStereo=True)</code>","text":"<p>Search for a chemical by CASRN; casrn is an integer without dashes. Returns a JSON object. Example output: [     {         \"SubstanceType\": \"Unknown\",         \"ChemId\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",         \"Cas\": 0,         \"ECNumber\": \"string\",         \"Smiles\": \"string\",         \"Names\": [         \"string\"         ],         \"CasSmilesRelation\": \"string\"     } ]</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.search_chemid","title":"<code>search_chemid(chemid)</code>","text":"<p>Search for a chemical by ChemId. Returns a JSON object. Example output: {     \"SubstanceType\": \"Unknown\",     \"ChemId\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",     \"Cas\": 0,     \"ECNumber\": \"string\",     \"Smiles\": \"string\",     \"Names\": [     \"string\"     ],     \"CasSmilesRelation\": \"string\" }</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.search_name","title":"<code>search_name(name, options='ExactMatch', ignoreStereo=True)</code>","text":"<p>Search for a chemical by name. Returns a JSON object. options can be: \"ExactMatch\", \"StartWith\", \"Contains\" Example output: [     {         \"SubstanceType\": \"Unknown\",         \"ChemId\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",         \"Cas\": 0,         \"ECNumber\": \"string\",         \"Smiles\": \"string\",         \"Names\": [         \"string\"         ],         \"CasSmilesRelation\": \"string\"     } ]</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.search_smiles","title":"<code>search_smiles(smiles, registerUnknown=True, ignoreStereo=True)</code>","text":"<p>search for a chemical by SMILES. Returns a JSON object. Example output: [     {         \"SubstanceType\": \"Unknown\",         \"ChemId\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",         \"Cas\": 0,         \"ECNumber\": \"string\",         \"Smiles\": \"string\",         \"Names\": [         \"string\"         ],         \"CasSmilesRelation\": \"string\"     } ]</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.toolbox_version","title":"<code>toolbox_version(timeout=None)</code>","text":"<p>Get the version of the QSAR Toolbox If timeout is not provided, it will use the timeout provided in the class initialization. Example: qs = QSARToolbox(port=52675) qs.toolbox_version()</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.webapi_version","title":"<code>webapi_version(timeout=None)</code>","text":"<p>Get the version of the API Example: qs = QSARToolbox(port=52675) qs.api_version()</p>"},{"location":"api/#pyqsartoolbox.qsartoolbox.QSARToolbox.workflow_on_chemical","title":"<code>workflow_on_chemical(workflow_guid, chem_id, timeout=None)</code>","text":"<p>Run a workflow on a chemical.</p>"},{"location":"extract_data/","title":"Data","text":"<p>It is possible to look for the experimental data shipped with the <code>QSAR Toolbox</code>. To retrieve data, you need to provide <code>ChemId</code> and the end point position from the enpoints tree. The entire end points tree can be obtained by the method <code>get_endpoints_tree</code>. It returns a <code>list</code> of the available end points:</p> <pre><code>endpoints_tree = qs.get_endpoints_tree()\n</code></pre> <p>The above command must produce the following list (perhaps with minor difference depending on your QSAR Toolbox installation):</p> Click to expand the endpoints tree list <pre><code>['Physical Chemical Properties',\n 'Environmental Fate and Transport',\n 'Ecotoxicological Information',\n 'Intermediate effects - mechanistic information',\n 'Observed metabolism',\n 'Human Health Hazards',\n 'Physical Chemical Properties#Autoflammability / Self-ignition temperature',\n 'Physical Chemical Properties#Vapour pressure',\n 'Physical Chemical Properties#Boiling point',\n 'Physical Chemical Properties#Viscosity',\n 'Physical Chemical Properties#Oxidation reduction potential',\n 'Physical Chemical Properties#Self-reactive substances',\n 'Physical Chemical Properties#Surface tension',\n 'Physical Chemical Properties#Gases under pressure',\n 'Physical Chemical Properties#pH',\n 'Physical Chemical Properties#Particle size',\n 'Physical Chemical Properties#Flash point',\n 'Physical Chemical Properties#Density',\n 'Physical Chemical Properties#Solubility in organic solvents / fat solubility',\n 'Physical Chemical Properties#Water solubility',\n 'Physical Chemical Properties#Oxidising properties',\n 'Physical Chemical Properties#Explosive properties',\n 'Physical Chemical Properties#Chemical reactivity',\n 'Physical Chemical Properties#Stability in organic solvents and identity of relevant degradation products',\n 'Physical Chemical Properties#Melting / freezing point',\n 'Physical Chemical Properties#Dissociation Constant (pKa)',\n 'Physical Chemical Properties#Corrosivity to metals',\n 'Physical Chemical Properties#Flammability',\n 'Physical Chemical Properties#Partition Coefficient:',\n 'Physical Chemical Properties#Partition Coefficient:#Gas/Atmospheric particulates',\n 'Physical Chemical Properties#Partition Coefficient:#N-Octanol/Air',\n 'Physical Chemical Properties#Partition Coefficient:#N-Octanol/Water',\n 'Environmental Fate and Transport#Stability',\n 'Environmental Fate and Transport#Transport and Distribution',\n 'Environmental Fate and Transport#Biodegradation',\n 'Environmental Fate and Transport#Bioaccumulation',\n 'Environmental Fate and Transport#Stability#Hydrolysis',\n 'Environmental Fate and Transport#Stability#Photodegradation',\n 'Environmental Fate and Transport#Stability#Photodegradation#in air',\n 'Environmental Fate and Transport#Stability#Photodegradation#in soil',\n 'Environmental Fate and Transport#Stability#Photodegradation#in water',\n 'Environmental Fate and Transport#Transport and Distribution#Adsorption/desorption',\n 'Environmental Fate and Transport#Transport and Distribution#Monitoring data',\n 'Environmental Fate and Transport#Transport and Distribution#Distribution modelling',\n \"Environmental Fate and Transport#Transport and Distribution#Henry's Law constant (H)\",\n 'Environmental Fate and Transport#Transport and Distribution#Water Volatilization Half-lives',\n 'Environmental Fate and Transport#Biodegradation#in water and sediment: simulation tests',\n 'Environmental Fate and Transport#Biodegradation#in Sewage Treatment Plant',\n 'Environmental Fate and Transport#Biodegradation#in water: screening tests',\n 'Environmental Fate and Transport#Biodegradation#in soil',\n 'Environmental Fate and Transport#Bioaccumulation#aquatic / sediment',\n 'Environmental Fate and Transport#Bioaccumulation#terrestrial',\n 'Ecotoxicological Information#Sediment Toxicity',\n 'Ecotoxicological Information#Aquatic Toxicity',\n 'Ecotoxicological Information#Terrestrial Toxicity',\n 'Human Health Hazards#Genetic Toxicity',\n 'Human Health Hazards#Repeated Dose Toxicity',\n 'Human Health Hazards#Toxicokinetics, Metabolism and Distribution',\n 'Human Health Hazards#Developmental Toxicity / Teratogenicity',\n 'Human Health Hazards#Toxicity to Reproduction',\n 'Human Health Hazards#Neurotoxicity',\n 'Human Health Hazards#Specific investigations',\n 'Human Health Hazards#Sensitisation',\n 'Human Health Hazards#Immunotoxicity',\n 'Human Health Hazards#Irritation / Corrosion',\n 'Human Health Hazards#Photoinduced toxicity',\n 'Human Health Hazards#ToxCast',\n 'Human Health Hazards#Carcinogenicity',\n 'Human Health Hazards#Acute Toxicity',\n 'Human Health Hazards#Toxicokinetics, Metabolism and Distribution#Dermal absorption',\n 'Human Health Hazards#Toxicokinetics, Metabolism and Distribution#Basic toxicokinetics',\n 'Human Health Hazards#Specific investigations#Endocrine disrupter',\n 'Human Health Hazards#Specific investigations#other studies']\n</code></pre> <p>You then need to look for the desired end point in the tree using the right keyword. For instance, we look for \"henry\" to find the position of the Henry's law constant in the end points tree. We then need to call another function to find all the available end points for the obtained position:</p> <pre><code>henry_position = [e for e in endpoints_tree if \"henry\" in e.lower()]\nif len(henry_position) &gt; 0:\n    henry_position = henry_position[0]\nprint(f\"Henry position: {henry_position}\")\navailable_henry_endpoints = qs.get_endpoints_from_tree(henry_position)\nif len(available_henry_endpoints) &gt; 0:\n    available_henry_endpoints = available_henry_endpoints[1]\nprint(f\"Available endpoints: {available_henry_endpoints}\")\n</code></pre> <p>It is now possible to look for this end point for a specific chemical ID. I repeat the procedure for CAS RN \"50-00-0\" (formaldehyde):</p> <pre><code>casrn = \"50-00-0\"  # formaldehyde\nres_chem_cas = qs.search_CAS(casrn)\nHLC_value = qs.get_endpoint_data(\n    chem_id=res_chem_cas[0][\"ChemId\"],\n    position=henry_position,\n    endpoint=available_henry_endpoints,\n)\nprint(f\"Henry's law constant experimental value is {(HLC_value[0]['Value'])} {(HLC_value[0]['Unit'])}\")\n</code></pre> <p>There are other ways of looking at the endpoints tree. For instance, one useful way is to get all the endpoints for <code>Environmental Fate and Transport#Transport and Distribution</code>. This give all the endpoints available in the databases for the given category:</p> <pre><code>all_endpoint_transport = qs.get_endpoints_from_tree(\n    \"Environmental Fate and Transport#Transport and Distribution\"\n)\nprint(f\"Available endpoints: {all_endpoint_transport}\")\n</code></pre> <p>And finally, the user can find from which database an end point is extracted. For example, for the Henry's law constant, we can find the name of the database by calling the following method:</p> <pre><code>pKa_positions = [\n    e for e in endpoints_tree if \"pka\" in e.lower() or \"pka\" in e.lower()\n]\npKa_position = pKa_positions[0] \navailable_pKa_endpoints = qs.get_endpoints_from_tree(pKa_position)\nfor endpoint in available_pKa_endpoints:\n    pKa_database = qs.get_databases_for_endpoint(\n        position=pKa_position, endpoint=endpoint\n    )\n    print(f\"Available databases for {endpoint}: {pKa_database}\")\n</code></pre>"},{"location":"extract_data/#next-step","title":"Next step","text":"<p>When there is no experimental data, you can call a QSAR model to estimate the desired parameter values.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through setting up and using the client effectively.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install the official QSAR Toolbox application locally and start its Web API service.</li> <li>Find the listening port of the local server (see below if unknown).</li> </ol>"},{"location":"getting-started/#finding-the-port-automatically","title":"Finding the Port Automatically","text":"<pre><code>import psutil, requests\nfrom requests.exceptions import RequestException\n\ndef find_open_port(endpoint=\"/about/toolbox/version\", host=\"127.0.0.1\"):\n    for conn in psutil.net_connections():\n        if conn.status == \"LISTEN\" and getattr(conn.laddr, 'ip', host) == host:\n            port = conn.laddr.port\n            try:\n                r = requests.get(f\"http://{host}:{port}/api/v6{endpoint}\", timeout=1)\n                if r.status_code == 200:\n                    return port\n            except RequestException:\n                continue\n    return None\n\nprint(\"Detected port:\", find_open_port())\n</code></pre>"},{"location":"getting-started/#instantiating-the-client","title":"Instantiating the Client","text":"<pre><code>from pyqsartoolbox import QSARToolbox\nqs = QSARToolbox(port=port_number, timeout=30) # use the port given by QSAR Toolbox Websuite\napi_version = qs.webapi_version()\ntoolbox_version = qs.toolbox_version()\nprint(f\"API version: {api_version}\")\nprint(f\"Toolbox version: {toolbox_version}\")\n</code></pre>"},{"location":"getting-started/#endpoint-tree","title":"Endpoint tree","text":"<p>The following figure shows a graph of the end point tree: </p>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Most methods raise ValueError with the HTTP status code if the API responds with an error. Wrap calls in try/except for resilience.</p>"},{"location":"getting-started/#next-step","title":"Next Step","text":"<p>How to search the databases for chemicals using different identifiers.</p>"},{"location":"run_qsar/","title":"QSAR models","text":"<p>We can call the available QSAR models for a chemical and an end point position selected from the end point tree. Here's how we can get a list of the available QSAR models for estimating the Henry's law constant, and then call the models for a given chemID:</p> <pre><code>henry_qsar_models = qs.get_qsar_models(position=henry_position)\nprint(f\"Available QSAR models: {henry_qsar_models}\")\n\nHLC_QSAR_list = []\nfor model in henry_qsar_models:\n    HLC_QSAR = {}\n    res = qs.apply_qsar_chemical(\n        res_chem_cas[0][\"ChemId\"], qsar_model_guid=model[\"Guid\"]\n    )\n    HLC_QSAR[model[\"Caption\"]] = res[\"Value\"]\n    HLC_QSAR[\"Unit\"] = res[\"Unit\"]\n    HLC_QSAR_list.append(HLC_QSAR)\nprint(HLC_QSAR_list)\n</code></pre> <p>The above values are estimated with the available QSAR methods for the Henry's law constant in the QSAR Toolbox. However, there is another way to do it, which is using <code>calculators</code>.    * Note: the OPERA interface takes longer to run (probably for converting SMILES to structure), between 2-5 minutes. Therefore, I suggest not running it from this interface and running it directly from <code>OPERA CLI</code>. We will release a Python package for doing it automatically.</p> <pre><code>calculators_list = qs.get_available_calculators()\nhenry_calculators = []\nhenry_calculator_values = []\nfor c in calculators_list:\n    if \"henry\" in c[\"Caption\"].lower():\n        h = {}\n        h[\"Caption\"] = c[\"Caption\"]\n        res = qs.run_calculator(\n            calculation_guid=c[\"Guid\"], chem_id=res_chem_cas[0][\"ChemId\"]\n        )\n        h[\"Value\"] = res[\"Value\"]\n        h[\"Unit\"] = res[\"Unit\"]\n        henry_calculator_values.append(h)\n        henry_calculators.append(c)\nprint(henry_calculator_values)\n</code></pre> <p>Although not systematically tested, the <code>calculators</code> seem to run faster than models, and therefore can be recommended for longer list of chemicals.</p>"},{"location":"run_qsar/#next-step","title":"Next step","text":"<p>An step by step guide for obtaining experimental data and QSAR model results from QSAR Toolbox via Python.</p>"},{"location":"search_chemicals/","title":"Search for chemicals","text":"<p>Search can be conducted by CAS, name, SMILES, or ChemID. The ChemID is a long string of the following format <code>323eca7f-fe36-6959-a6fd-1ae6839278b0</code>; therefore, it is highly unlikely that someone uses this function. Other identifiers, however, can be used as shown in the following examples.</p>"},{"location":"search_chemicals/#search-by-name","title":"Search by name","text":"<p>The name can be specifed as a string and three options of \"ExactMatch\" (default), \"StartWith\", and \"Contains\" are available. It is possible to find multiple chemicals for a specified name; the results are returned as a <code>list</code> of <code>Dict</code>, with each item referring to a single chemical with a unique <code>ChemId</code>.</p> <pre><code>chem_name = \"caffeine\"\noptions = [\"ExactMatch\", \"StartWith\", \"Contains\"]\nfor option in options:\n    res_chem_name = qs.search_name(chem_name, options=option)\n    print(f\"Found {len(res_chem_name)} chemicals for {option} option\")\nres_chem_name = qs.search_name(chem_name, options=\"ExactMatch\")\ncas_number = [chem[\"Cas\"] for chem in res_chem_name]\n</code></pre> <p>As you can see, the exact match for <code>caffeine</code> found fewer results, but more chemicals are found for compund names that starts with or contains the word caffeine.</p>"},{"location":"search_chemicals/#search-by-cas-and-smiles","title":"Search by CAS and SMILES","text":"<p>The cas number must be an integer without the customary dash, e.g. 50000 instead of \"50-00-0\" that is the CAS number of formaldehyde. The wrapper function, however, accepts both values.</p> <pre><code>casrn = \"50-00-0\"  # formaldehyde\nres_chem_cas = qs.search_CAS(casrn)\nprint(f\"Found {len(res_chem_cas)} chemicals for CAS number {casrn}\")\nprint(\n    f\"The chemical is called {res_chem_cas[0]['Names'][0]}, with SMILES {res_chem_cas[0]['Smiles']}, and ChemId {res_chem_cas[0]['ChemId']}\"\n)\n</code></pre> <p>We can also search for the same chemical using SMILES:</p> <pre><code>smiles = \"C=O\"  # formaldehyde\nres_chem_smiles = qs.search_smiles(smiles)\nprint(f\"Found {len(res_chem_smiles)} chemicals for SMILES {smiles}\")\n</code></pre> <p>Searching by the <code>CAS RN</code> gives a unique answer (note that a CAS RN refers to a unique chemical, but it does not mean that a chemical is identified by a single CASRN. Multiple CAS RN can refer to the same chemical). Searching by <code>SMILES</code> can find more than a single chemical, as you can see in the above call with <code>C=O</code> that is the <code>SMILES</code> string for formaldehyde.</p>"},{"location":"search_chemicals/#next-step","title":"Next Step","text":"<p>How to extract experimental data for a chemical.</p>"},{"location":"step_by_step/","title":"Step by step guide","text":"<p>This page shows an example of the usage of <code>PyQSARToolbox</code> based on one of the author's projects.</p>"},{"location":"step_by_step/#problem-statement","title":"Problem statement","text":"<p>We have a list of compounds identified by their <code>CAS RN</code> and <code>SMILES</code>. We want to call all the available QSAR models for vapor pressure and also extract the available experimental data. </p>"},{"location":"step_by_step/#step-1-extract-chemid","title":"Step 1: extract <code>ChemId</code>","text":"<p>First, we look for the <code>ChemId</code> for all the compounds, first by searching with <code>CAS RN</code>, followed by <code>SMILES</code> and potentially <code>names</code>.</p> <pre><code># water solubility of 50-03-3\nchem_by_cas = qs.search_CAS(\"50-03-3\")\nchem_id = chem_by_cas[0][\"ChemId\"]\n</code></pre>"},{"location":"step_by_step/#step-2-find-the-location-of-endpoint","title":"Step 2: find the location of endpoint","text":"<p>We get the <code>endpoint tree</code> and look for the desired endpoint in it. The goal is to extract the positions in the tree that seem to be relevant to our desired endpoint properties.</p> <p>WARNING: you can find irrelevant values too, depending on the keywords used to search for the endpoints.</p> <pre><code>endpoints_tree = qs.get_endpoints_tree()\nwater_solubility_position = [\n    e for e in endpoints_tree if \"water solubility\" in e.lower()\n][0]\n</code></pre>"},{"location":"step_by_step/#step-3-extracting-data","title":"Step 3: extracting data","text":"<p>After finding the position of the desired endpoint in the tree, we use it to find the available data and models for it. First, we have to get the available endpoint for the selected position in the endpoints tree by calling the method <code>get_endpoints_from_tree</code>:</p> <pre><code>available_water_solubility_endpoints = qs.get_endpoints_from_tree(\n    water_solubility_position\n)\nprint(\"Available endpoints:\")\nfor endpoint in available_water_solubility_endpoints:\n    print(\"  - \" + endpoint)\n</code></pre> <p>As you can see, the first entry does not match what we are looking for (which is the solubility of organic compounds). Therefore, we will only use the last two elements (note the small and capital <code>W</code> in water. It becomes important because each one refers to a different dataset!) Here's how we can search for data using the method <code>get_endpoint_data</code>:</p> <pre><code>water_solubility_values = [\n    qs.get_endpoint_data(\n        chem_id=chem_id,\n        position=water_solubility_position,\n        endpoint=available_water_solubility_endpoints[i],\n    )\n    for i in [1, 2]\n]\n# print each end point dict in the list\nfor i in range(len(water_solubility_values)):\n    print(json.dumps(water_solubility_values[i], indent=2))\n</code></pre>"},{"location":"step_by_step/#step-4-running-qsar-models","title":"Step 4: running QSAR models","text":"<p>The above results are identical for both <code>water solubility</code> entries with small and capital <code>W</code>. Now, we can find the <code>QSAR</code> models for the same endpoints. It is done by calling the method <code>get_qsar_models</code>:</p> <pre><code># run QSAR model for water solubility\nws_qsar_models = qs.get_qsar_models(position=water_solubility_position)\nprint(f\"Available QSAR models:\")\nfor model in ws_qsar_models:\n    print(json.dumps(model, indent=2))\n</code></pre> <p>We can see that four models are available for predicting water solubility: two models from EPI Suite, and one model each for VEGA and OPERA. We can run the models now:</p> <pre><code># run the models and time each one\nimport time\n\nresults = []\nws_QSAR_list = []\nfor model in ws_qsar_models:\n    start = time.time()\n    res = qs.apply_qsar_chemical(chem_id, qsar_model_guid=model[\"Guid\"])\n    results.append(res)\n    end = time.time()\n    ws_QSAR = {}\n    res = qs.apply_qsar_chemical(chem_id, qsar_model_guid=model[\"Guid\"])\n    ws_QSAR[model[\"Caption\"]] = res[\"Value\"]\n    ws_QSAR[\"Unit\"] = res[\"Unit\"]\n    ws_QSAR_list.append(ws_QSAR)\n    print(f\"Time elapsed for {model['Caption']}: {end-start:.2f} seconds\")\n</code></pre> <p>On my system, I obtained the following run times (note the longer runtime of OPERA):  </p> <pre><code>Time elapsed for Water Solubility (EPISUITE): 0.06 seconds\nTime elapsed for VEGA - Water solubility model (IRFMN): 7.29 seconds\nTime elapsed for Water Solubility (fragments) (EPISUITE): 0.03 seconds\nTime elapsed for OPERA WS: 28.05 seconds\n</code></pre> <p>You can also dump the results as <code>JSON</code> for a higher readability:</p> <pre><code># print the results\nfor r in results:\n    print(json.dumps(r, indent=2))\n</code></pre>"},{"location":"step_by_step/#step-4-alternative-using-calculators","title":"Step 4 (alternative): using calculators","text":"<p>Another way of calling <code>QSAR</code> model in QSAR Toolbox is using <code>calculators</code>. First, we need to get the list of the available calculators:</p> <pre><code>calculators_list = qs.get_available_calculators()\ncalculators_list\n</code></pre> <p>There are too many of these calculators. We can look for the right one by looking into the 'Caption' or 'Description' of each element. For instance, we can look for 'water solubility':</p> <pre><code>WS_calculators = []\nfor c in calculators_list:\n    if \"water solubility\" in c[\"Caption\"].lower():\n        WS_calculators.append(c)\nprint(WS_calculators)\n</code></pre> <p>Note that these calculators are only available for the \"native\" QSAR Toolbox methods and data. The addons (e.g. VEGA and OPERA) are either not part of the calculators or possibly I could not find them. Now, we can call the calculators using the method <code>run_calculator</code> for a specified chemical.</p> <pre><code>WS_values = []\nfor c in WS_calculators:\n    res = qs.run_calculator(calculation_guid=c[\"Guid\"], chem_id=chem_id)\n    WS_values.append(res)\nprint(WS_values)\n</code></pre> <p>The advantage of using <code>calculators</code> over the alternative methods is that it is simpler to set up and also faster computationally (based on my limited tests).</p>"},{"location":"step_by_step/#next-step","title":"Next step","text":"<p>Have a look at the QSAR Toolbox <code>workflows</code>.</p>"},{"location":"workflows/","title":"Workflows","text":"<p>There is another option in the QSAR Toolbox called <code>workflows</code>. Here's how we can get a list of the available ones:</p> <pre><code>workflows = qs.get_workflows()\nprint(workflows)\n</code></pre> <p>The following workflows are available for my QSAR Toolbox (v 4.8) installation:</p> <pre><code>[{'Caption': 'Skin sensitisation from GPMT assay',\n  'Guid': '36d8cd9a-bf22-4d8f-8690-468affb13a39',\n  'Endpoint': 'S M W N &lt;OR&gt; Skin sensitisation',\n  'RigidPath': 'Human Health Hazards#Sensitisation'},\n {'Caption': 'Fish, LC50(EC50) at 96h for Pimephales promelas (mortality)',\n  'Guid': 'ba31e827-bf06-4a27-81ae-56aaa763ce36',\n  'Endpoint': 'EC50 &lt;OR&gt; LC50',\n  'RigidPath': 'Ecotoxicological Information#Aquatic Toxicity'},\n {'Caption': 'Demo workflow',\n  'Guid': '33b163fd-7e42-47f8-b52c-59d911785aa8',\n  'Endpoint': None,\n  'RigidPath': None},\n {'Caption': 'tb_sys_default_functions',\n  'Guid': '8225142f-5c56-4fd5-918e-70a181f0dffb',\n  'Endpoint': None,\n  'RigidPath': None},\n {'Caption': 'EC3 from LLNA or Skin sensitisation from GPMT assays',\n  'Guid': '2a26b617-d8e8-4a32-9dd6-06e983ae44be',\n  'Endpoint': 'EC3 &lt;OR&gt; S M W N &lt;OR&gt; Skin sensitisation',\n  'RigidPath': 'Human Health Hazards#Sensitisation'},\n {'Caption': 'EC3 from LLNA assay',\n  'Guid': '14fe5e12-fec8-4ac1-ba53-1dd9874fe031',\n  'Endpoint': 'EC3',\n  'RigidPath': 'Human Health Hazards#Sensitisation'},\n {'Caption': 'EC3 from LLNA or Skin sensitization from GPMT assays for defined approaches (SS AW for DASS)',\n  'Guid': '0c5bc24e-da70-46d5-9165-adbe21dc5935',\n  'Endpoint': 'EC3 &lt;OR&gt; S M W N &lt;OR&gt; Skin sensitisation',\n  'RigidPath': 'Human Health Hazards#Sensitisation'}]\n</code></pre> <p>It is possible to call the above workflows on a chemical using the method <code>workflow_on_chemical</code>. For instance, the following code runs workflow for Skin sensitisation from GPMT assay for chemical formaldehyde.</p> <pre><code>chem = qs.search_CAS(\"50-00-0\")\nchem_id = chem[0][\"ChemId\"]\nprint(f\"Running workflow {workflows[0]['Caption']} for chemical {chem[0][\"Names\"][0]}\")\nres = qs.workflow_on_chemical(workflow_guid=workflows[0][\"Guid\"], chem_id=chem_id)\nprint(res)\n</code></pre> <p>{'Result': 'Positive from \" Subcategorized: Protein binding alerts for skin sensitization by OASIS \" for C=O',  'Prediction': {'DomainResult': None,   'DomainExplain': None,   'DataType': 'Read-across prediction.',   'RigidPath': 'Human Health Hazards#Sensitisation',   'Endpoint': 'S M W N  Skin sensitisation',   'MetaData': None,   'Value': 'Positive',   'Qualifier': None,   'MinValue': None,   'MinQualifier': None,   'MaxValue': None,   'MaxQualifier': None,   'Unit': None,   'Family': None}} <p>## Next step   Have a look at the API and give it a shot!</p>"}]}